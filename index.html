<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>RealCam — Canvas合成 + アニメ</title>
<style>
  :root{ --bg:#000; --muted:#999; --accent:#ff6b9f; }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;overflow:hidden;}
  .wrap{max-width:430px;margin:0 auto;padding:14px;display:flex;flex-direction:column;align-items:center;height:100dvh;}
  .header{height:60px;width:100%;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:22px}
  .viewport{
    width:100%;aspect-ratio:9/16;background:#111;border-radius:18px;overflow:hidden;position:relative;
    box-shadow:0 10px 30px rgba(0,0,0,0.6);touch-action:none;
  }
  #rearVideo{width:100%;height:100%;object-fit:cover;display:block;background:#000}
  .front-box{
    position:absolute;left:14px;top:14px;width:110px;height:145px;
    border-radius:16px;overflow:hidden;border:3px solid rgba(0,0,0,0.5);
    background:#222;z-index:30;touch-action:none;
  }
  #frontVideo{width:100%;height:100%;object-fit:cover;transform:scaleX(-1);}
  .time-badge{position:absolute;left:16px;bottom:14px;background:rgba(0,0,0,0.55);padding:6px 10px;border-radius:10px;font-weight:700;z-index:40}
  .flash{position:absolute;inset:0;background:#fff;opacity:0;pointer-events:none;z-index:80}
  .flash.anim{animation:flashAnim .4s ease-out}
  @keyframes flashAnim{0%{opacity:1}100%{opacity:0}}
  .controls{margin-top:16px;display:flex;gap:12px;align-items:center}
  .circle-btn{width:78px;height:78px;border-radius:50%;border:5px solid #fff;display:flex;align-items:center;justify-content:center;background:transparent;cursor:pointer}
  .circle-inner{width:100%;height:100%;border-radius:50%;background:#fff}
  .small{padding:10px 16px;border-radius:18px;background:#222;border:none;color:#fff;cursor:pointer;font-weight:700}
  .small:disabled{opacity:0.3}
  .status{margin-top:10px;color:var(--muted);font-size:14px;text-align:center}
  #result{position:fixed;inset:0;background:rgba(0,0,0,0.95);display:none;align-items:center;justify-content:center;flex-direction:column;z-index:200}
  .result-card{width:94%;max-width:420px;background:#000;border-radius:18px;overflow:hidden}
  #finalPreview{width:100%;display:block;background:#111}
  .result-footer{padding:14px;display:flex;gap:8px;align-items:center;justify-content:space-between}
  .send-btn{background:transparent;border:none;color:#fff;font-weight:900;font-size:28px;cursor:pointer}
  .retake,.download{padding:10px 14px;border-radius:14px;font-weight:700;cursor:pointer;color:#fff;border:none}
  .retake{background:#222}
  .download{background:var(--accent)}
  .send-anim{animation:sendUp .7s ease forwards}
  @keyframes sendUp{0%{transform:translateY(0);opacity:1}100%{transform:translateY(-20px);opacity:0}}
</style>
</head>
<body>
  <div class="wrap">
    <div class="header">BeReal-ish</div>
    <div class="viewport" id="viewport">
      <div class="flash" id="flashLayer"></div>
      <video id="rearVideo" autoplay playsinline muted></video>
      <div class="front-box" id="frontBox"><video id="frontVideo" autoplay playsinline muted></video></div>
      <div class="time-badge" id="timeBadge">--:--</div>
    </div>
    <div class="controls">
      <button class="circle-btn" id="captureBtn"><div class="circle-inner"></div></button>
      <button class="small" id="saveBtn" disabled>保存</button>
      <button class="small" id="openResultBtn" disabled>SEND画面</button>
    </div>
    <div class="status" id="status">Tap to capture ✨</div>
  </div>

  <div id="result">
    <div class="result-card" id="resultCard">
      <img id="finalPreview" alt="final"/>
      <div class="result-footer">
        <div style="display:flex;gap:8px">
          <button class="retake" id="retakeBtn">撮り直し</button>
          <button class="download" id="downloadBtn">保存する</button>
        </div>
        <button class="send-btn" id="sendBtn">SEND ▶</button>
      </div>
    </div>
  </div>

<script>
const rearVideo = document.getElementById('rearVideo');
const frontVideo = document.getElementById('frontVideo');
const frontBox = document.getElementById('frontBox');
const captureBtn = document.getElementById('captureBtn');
const flashLayer = document.getElementById('flashLayer');
const statusEl = document.getElementById('status');
const saveBtn = document.getElementById('saveBtn');
const openResultBtn = document.getElementById('openResultBtn');
const resultModal = document.getElementById('result');
const finalPreview = document.getElementById('finalPreview');

let rearCanvas, frontCanvas, composedBlob;

// Time
function updateTime(){
  const n = new Date();
  document.getElementById('timeBadge').textContent = String(n.getHours()).padStart(2,'0') + ':' + String(n.getMinutes()).padStart(2,'0');
}
updateTime(); setInterval(updateTime, 10000);

// Drag
let dragging = false, sX, sY, iX, iY;
frontBox.addEventListener('pointerdown', e => {
  dragging = true; sX = e.clientX; sY = e.clientY;
  iX = frontBox.offsetLeft; iY = frontBox.offsetTop;
  frontBox.setPointerCapture(e.pointerId);
});
window.addEventListener('pointermove', e => {
  if(!dragging) return;
  const vp = document.getElementById('viewport');
  let nx = iX + (e.clientX - sX), ny = iY + (e.clientY - sY);
  nx = Math.max(8, Math.min(vp.clientWidth - 118, nx));
  ny = Math.max(8, Math.min(vp.clientHeight - 153, ny));
  frontBox.style.left = nx + 'px'; frontBox.style.top = ny + 'px';
});
window.addEventListener('pointerup', () => dragging = false);

// Camera Logic: 映像が本当に流れるまで待つ
async function getActiveStream(videoEl, mode) {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: mode, width: { ideal: 1280 }, height: { ideal: 1280 } }
  });
  videoEl.srcObject = stream;
  return new Promise((resolve) => {
    videoEl.onloadedmetadata = () => {
      videoEl.play();
      // 重要：readyStateが4（十分なデータあり）になるまで少し待つ
      const check = setInterval(() => {
        if (videoEl.readyState >= 3 && videoEl.videoWidth > 0) {
          clearInterval(check);
          resolve(stream);
        }
      }, 100);
    };
  });
}

function snap(videoEl) {
  const c = document.createElement('canvas');
  c.width = videoEl.videoWidth;
  c.height = videoEl.videoHeight;
  const ctx = c.getContext('2d');
  if(videoEl === frontVideo) { ctx.translate(c.width, 0); ctx.scale(-1, 1); }
  ctx.drawImage(videoEl, 0, 0);
  return c;
}

async function startCapture() {
  statusEl.textContent = 'Wait... (Rear Camera)';
  try {
    const s1 = await getActiveStream(rearVideo, 'environment');
    await new Promise(r => setTimeout(r, 700)); // 露出調整待ち
    flashLayer.classList.add('anim');
    rearCanvas = snap(rearVideo);
    s1.getTracks().forEach(t => t.stop());
    setTimeout(() => flashLayer.classList.remove('anim'), 400);

    statusEl.textContent = 'Smile! (Front Camera)';
    const s2 = await getActiveStream(frontVideo, 'user');
    await new Promise(r => setTimeout(r, 700));
    frontCanvas = snap(frontVideo);
    s2.getTracks().forEach(t => t.stop());

    await compose();
    statusEl.textContent = 'Done! ✨';
    saveBtn.disabled = openResultBtn.disabled = false;
  } catch (e) {
    statusEl.textContent = 'Error: Check Permissions';
    console.error(e);
  }
}

async function compose() {
  const W = 1080, H = 1440;
  const canvas = document.createElement('canvas');
  canvas.width = W; canvas.height = H;
  const ctx = canvas.getContext('2d');

  ctx.fillStyle = '#050505'; ctx.fillRect(0,0,W,H);
  
  // Rear Draw
  const rRatio = Math.min(rearCanvas.width/W, rearCanvas.height/(H*0.8));
  const rw = W * rRatio, rh = (H*0.8) * rRatio;
  ctx.drawImage(rearCanvas, (rearCanvas.width-rw)/2, (rearCanvas.height-rh)/2, rw, rh, 0, 0, W, H*0.8);

  // Front Draw (Position from UI)
  const ratio = W / document.getElementById('viewport').clientWidth;
  const fw = 110 * ratio, fh = 145 * ratio;
  const fx = (parseInt(frontBox.style.left) || 14) * ratio;
  const fy = (parseInt(frontBox.style.top) || 14) * ratio;

  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = 40;
  // Rounded Rect Clip
  ctx.beginPath();
  ctx.roundRect ? ctx.roundRect(fx, fy, fw, fh, 25) : ctx.rect(fx, fy, fw, fh);
  ctx.fill(); ctx.clip();
  ctx.drawImage(frontCanvas, fx, fy, fw, fh);
  ctx.restore();

  // Time
  ctx.fillStyle = '#fff'; ctx.font = 'bold 40px sans-serif';
  ctx.fillText(document.getElementById('timeBadge').textContent, 50, H * 0.75);

  finalPreview.src = canvas.toDataURL('image/jpeg', 0.9);
  canvas.toBlob(b => { composedBlob = b; }, 'image/jpeg', 0.9);
}

// Download Fix: Blobを使う
function download() {
  if(!composedBlob) return;
  const url = URL.createObjectURL(composedBlob);
  const a = document.createElement('a');
  a.href = url; a.download = `BeReal_${Date.now()}.jpg`;
  document.body.appendChild(a); a.click();
  setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
}

captureBtn.onclick = startCapture;
saveBtn.onclick = download;
document.getElementById('downloadBtn').onclick = download;
openResultBtn.onclick = () => resultModal.style.display = 'flex';
document.getElementById('retakeBtn').onclick = () => { resultModal.style.display = 'none'; };
document.getElementById('sendBtn').onclick = () => {
  document.getElementById('resultCard').classList.add('send-anim');
  setTimeout(() => {
    resultModal.style.display = 'none';
    document.getElementById('resultCard').classList.remove('send-anim');
    alert('送信完了（したフリ）！');
  }, 700);
};
</script>
</body>
</html>
