<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>RealCam â€” Canvasåˆæˆ + ã‚¢ãƒ‹ãƒ¡</title>
<style>
  :root{
    --bg:#000; --muted:#999; --accent:#ff6b9f;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
  .wrap{max-width:430px;margin:0 auto;padding:14px;display:flex;flex-direction:column;align-items:center}
  .header{height:60px;width:100%;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:22px}
  .viewport{
    width:100%;aspect-ratio:9/16;background:#111;border-radius:18px;overflow:hidden;position:relative;
    box-shadow:0 10px 30px rgba(0,0,0,0.6);
  }
  /* rear video full */
  #rearVideo{width:100%;height:100%;object-fit:cover;display:block}
  /* small front preview draggable */
  .front-box{position:absolute;left:14px;top:14px;width:110px;height:150px;border-radius:16px;overflow:hidden;border:3px solid rgba(0,0,0,0.5);background:#222;z-index:30;touch-action:none;display:flex;align-items:center;justify-content:center}
  #frontVideo{width:100%;height:100%;object-fit:cover;transform:scaleX(-1);} /* mirror */
  /* overlay time */
  .time-badge{position:absolute;left:16px;bottom:14px;background:rgba(0,0,0,0.55);padding:6px 10px;border-radius:10px;font-weight:700;z-index:40}
  /* flash */
  .flash{position:absolute;inset:0;background:#fff;opacity:0;pointer-events:none;z-index:80}
  .flash.anim{animation:flashAnim .45s ease-out}
  @keyframes flashAnim{0%{opacity:1}100%{opacity:0}}
  /* controls */
  .controls{margin-top:16px;display:flex;gap:12px;align-items:center}
  .circle-btn{width:78px;height:78px;border-radius:50%;border:5px solid #fff;display:flex;align-items:center;justify-content:center;background:transparent;cursor:pointer}
  .circle-inner{width:100%;height:100%;border-radius:50%;background:#fff}
  .small{padding:10px 16px;border-radius:18px;background:#222;border:none;color:#fff;cursor:pointer;font-weight:700}
  .status{margin-top:10px;color:var(--muted);font-size:14px}
  /* result modal */
  #result{position:fixed;inset:0;background:rgba(0,0,0,0.95);display:none;align-items:center;justify-content:center;flex-direction:column;z-index:200}
  .result-card{width:94%;max-width:420px;background:#000;border-radius:18px;overflow:hidden;box-shadow:0 20px 50px rgba(0,0,0,0.7)}
  #finalPreview{width:100%;display:block}
  .result-footer{padding:14px;display:flex;gap:8px;align-items:center;justify-content:space-between}
  .send-btn{background:transparent;border:none;color:#fff;font-weight:900;font-size:28px;cursor:pointer}
  .retake{background:#222;padding:10px 14px;border-radius:14px;font-weight:700;cursor:pointer;color:#fff}
  .download{background:var(--accent);padding:10px 14px;border-radius:14px;font-weight:700;cursor:pointer;color:#fff}
  /* SENDã‚¢ãƒ‹ãƒ¡ */
  .send-anim{animation:sendUp .7s ease forwards}
  @keyframes sendUp{0%{transform:translateY(0);opacity:1}100%{transform:translateY(-20px);opacity:0.0}}
  /* rounded rect helper for canvas (polyfill) */
</style>
</head>
<body>
  <div class="wrap">
    <div class="header">BeReal-ish</div>

    <div class="viewport" id="viewport">
      <div class="flash" id="flashLayer"></div>

      <!-- rear video placeholder -->
      <video id="rearVideo" autoplay playsinline muted></video>

      <!-- draggable front box -->
      <div class="front-box" id="frontBox" title="Drag me">
        <video id="frontVideo" autoplay playsinline muted></video>
      </div>

      <div class="time-badge" id="timeBadge">--:--</div>
    </div>

    <div class="controls">
      <button class="circle-btn" id="captureBtn" title="Capture">
        <div class="circle-inner"></div>
      </button>
      <button class="small" id="saveBtn" disabled>ä¿å­˜</button>
      <button class="small" id="openResultBtn" disabled>SENDç”»é¢</button>
    </div>

    <div class="status" id="status">Tap to capture. Safariã¯httpsæ¨å¥¨ã€‚</div>
  </div>

  <!-- result modal -->
  <div id="result" role="dialog" aria-hidden="true">
    <div class="result-card" id="resultCard">
      <img id="finalPreview" alt="final preview"/>
      <div class="result-footer">
        <div style="display:flex;gap:8px">
          <button class="retake" id="retakeBtn">Retake</button>
          <button class="download" id="downloadBtn">Download</button>
        </div>
        <button class="send-btn" id="sendBtn">SEND â–¶</button>
      </div>
    </div>
  </div>

<script>
/* --------------- ãƒ˜ãƒ«ãƒ‘ãƒ¼ --------------- */
const rearVideo = document.getElementById('rearVideo');
const frontVideo = document.getElementById('frontVideo');
const frontBox = document.getElementById('frontBox');
const captureBtn = document.getElementById('captureBtn');
const flashLayer = document.getElementById('flashLayer');
const statusEl = document.getElementById('status');
const timeBadge = document.getElementById('timeBadge');
const saveBtn = document.getElementById('saveBtn');
const openResultBtn = document.getElementById('openResultBtn');

const resultModal = document.getElementById('result');
const finalPreview = document.getElementById('finalPreview');
const retakeBtn = document.getElementById('retakeBtn');
const downloadBtn = document.getElementById('downloadBtn');
const sendBtn = document.getElementById('sendBtn');
const resultCard = document.getElementById('resultCard');

let rearCanvasEl = null; // canvas objects from capture
let frontCanvasEl = null;
let composedDataUrl = null;
let isCapturing = false;

function updateTime(){
  const n = new Date();
  timeBadge.textContent = String(n.getHours()).padStart(2,'0') + ':' + String(n.getMinutes()).padStart(2,'0');
}
updateTime(); setInterval(updateTime, 30_000);

/* Safari/HTTPS æ³¨æ„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
function showError(msg){
  statusEl.textContent = msg;
}

/* --------------- ãƒ‰ãƒ©ãƒƒã‚° for frontBox --------------- */
let dragging = false, sX=0, sY=0, initX=0, initY=0;
frontBox.addEventListener('pointerdown',(e)=>{
  dragging=true; sX=e.clientX; sY=e.clientY; initX=frontBox.offsetLeft; initY=frontBox.offsetTop;
  frontBox.setPointerCapture(e.pointerId);
});
window.addEventListener('pointermove',(e)=>{
  if(!dragging) return;
  const dx = e.clientX - sX; const dy = e.clientY - sY;
  const vp = document.getElementById('viewport');
  const maxX = vp.clientWidth - frontBox.clientWidth - 12;
  const maxY = vp.clientHeight - frontBox.clientHeight - 12;
  let nx = Math.max(8, Math.min(maxX, initX + dx));
  let ny = Math.max(8, Math.min(maxY, initY + dy));
  frontBox.style.left = nx + 'px'; frontBox.style.top = ny + 'px';
});
window.addEventListener('pointerup',()=>{ dragging=false; });

/* --------------- ã‚«ãƒ¡ãƒ©é †æ¬¡èµ·å‹•ï¼†æ’®å½±ï¼ˆiOSå‘ã‘ï¼‰ --------------- */
async function startStreamFor(videoEl, facingMode, idealWidth, idealHeight){
  const constraints = { video: { facingMode } };
  if(idealWidth) constraints.video.width = { ideal: idealWidth };
  if(idealHeight) constraints.video.height = { ideal: idealHeight };
  return await navigator.mediaDevices.getUserMedia(constraints);
}

function captureVideoToCanvas(videoEl){
  const c = document.createElement('canvas');
  const w = videoEl.videoWidth || videoEl.clientWidth || 640;
  const h = videoEl.videoHeight || videoEl.clientHeight || 480;
  c.width = w; c.height = h;
  const ctx = c.getContext('2d');
  // front is mirrored in preview; for final we want mirrored result (so keep mirror)
  if(videoEl === frontVideo){
    ctx.translate(w,0); ctx.scale(-1,1);
  }
  ctx.drawImage(videoEl,0,0,w,h);
  return c;
}

async function captureSequence(){
  if(isCapturing) return;
  isCapturing = true;
  composedDataUrl = null;
  saveBtn.disabled = true; openResultBtn.disabled = true;
  statusEl.textContent = 'STAY STILL...';

  try{
    // rear start
    const rearStream = await startStreamFor(rearVideo,'environment',1920,1280);
    rearVideo.srcObject = rearStream;
    await rearVideo.play().catch(()=>{});
    // small wait to stabilize exposure
    await new Promise(r=>setTimeout(r,600));

    // flash anim
    flashLayer.classList.add('anim');

    // capture rear
    rearCanvasEl = captureVideoToCanvas(rearVideo);

    // stop rear
    rearStream.getTracks().forEach(t=>t.stop());
    rearVideo.srcObject = null;

    // UI hint
    statusEl.textContent = 'NOW YOUR REACTION!';
    frontBox.classList.add('active');
    // "ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ™‚é–“"ã‚’æ¼”å‡º
    await new Promise(r=>setTimeout(r,900));

    // front start
    const frontStream = await startStreamFor(frontVideo,'user',1280,960);
    frontVideo.srcObject = frontStream;
    await frontVideo.play().catch(()=>{});
    await new Promise(r=>setTimeout(r,400));

    frontCanvasEl = captureVideoToCanvas(frontVideo);

    // stop front
    frontStream.getTracks().forEach(t=>t.stop());
    frontVideo.srcObject = null;
    frontBox.classList.remove('active');

    // åˆæˆ
    statusEl.textContent = 'COMPOSING...';
    await composeFinalImage();
    statusEl.textContent = 'Ready â€” ä¿å­˜ or SENDã—ã¦ã­ âœ¨';
    saveBtn.disabled = false; openResultBtn.disabled = false;
  }catch(err){
    console.error(err);
    showError('ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼ï¼šè¨­å®šã‚’ç¢ºèªã—ã¦ã­ï¼ˆSafariã¯httpsãŒå¿…è¦ã‹ã‚‚ï¼‰ğŸ“±');
  } finally {
    isCapturing = false;
  }
}

/* --------------- Canvasåˆæˆï¼ˆè§’ä¸¸ãƒ»å½±ãƒ»ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼‰ --------------- */
async function composeFinalImage(){
  // target size
  const OUT_W = 1080;
  const OUT_H = 1440; // 3:4
  const out = document.createElement('canvas');
  out.width = OUT_W; out.height = OUT_H;
  const ctx = out.getContext('2d');

  // èƒŒæ™¯ãƒ€ãƒ¼ã‚¯ã§å¡—ã‚Šã¤ã¶ã—
  ctx.fillStyle = '#07070a'; ctx.fillRect(0,0,OUT_W,OUT_H);

  // drawCover - rear as background (center-crop)
  await drawCoverCanvas(ctx, rearCanvasEl, 0, 0, OUT_W, Math.round(OUT_H * 0.72));

  // divide line
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(0, Math.round(OUT_H * 0.72) - 4, OUT_W, 4);

  // front small window size and pos - derive from frontBox css pos
  const vp = document.getElementById('viewport');
  // compute ratio between viewport and OUT dimensions for placement (approx)
  const vpRect = vp.getBoundingClientRect();
  const fx = parseInt(frontBox.style.left || 14,10);
  const fy = parseInt(frontBox.style.top || 14,10);
  const fw = frontBox.clientWidth;
  const fh = frontBox.clientHeight;
  // map these coords to OUT canvas: scale by ratio width
  const scale = OUT_W / vpRect.width;
  const tx = Math.round(fx * scale);
  const ty = Math.round(fy * scale * 0.72); // tiny vertical mapping bias
  const tw = Math.round(fw * scale);
  const th = Math.round(fh * scale);

  // Draw small rounded rect with shadow
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.55)';
  ctx.shadowBlur = 22;
  roundedRect(ctx, tx-2, ty-2, tw+4, th+4, 28);
  ctx.fillStyle = '#000';
  ctx.fill();
  ctx.clip();
  // draw front cover-fit into tx,ty,tw,th
  await drawCoverCanvas(ctx, frontCanvasEl, tx, ty, tw, th);
  ctx.restore();

  // timestamp badge (left bottom)
  const now = new Date();
  const hh = String(now.getHours()).padStart(2,'0');
  const mm = String(now.getMinutes()).padStart(2,'0');
  const label = hh + ':' + mm;
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(36, OUT_H - 120, 160, 56);
  ctx.fillStyle = '#fff';
  ctx.font = '34px system-ui, -apple-system';
  ctx.fillText(label, 52, OUT_H - 82);

  // optional watermark small
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.font = '18px system-ui';
  ctx.fillText('RealCam', OUT_W - 120, OUT_H - 40);

  // finalize
  composedDataUrl = out.toDataURL('image/jpeg', 0.92);
  finalPreview.src = composedDataUrl;
}

/* draw cover-fit from source canvas to destination rect */
async function drawCoverCanvas(dstCtx, srcCanvas, x, y, w, h){
  // if srcCanvas sometimes not yet sized, we handle it
  const sw = srcCanvas.width, sh = srcCanvas.height;
  const sRatio = sw / sh;
  const tRatio = w / h;
  let sx, sy, swc, shc;
  if(sRatio > tRatio){
    shc = sh; swc = Math.round(shc * tRatio); sx = Math.round((sw - swc)/2); sy = 0;
  } else {
    swc = sw; shc = Math.round(swc / tRatio); sx = 0; sy = Math.round((sh - shc)/2);
  }
  dstCtx.drawImage(srcCanvas, sx, sy, swc, shc, x, y, w, h);
}

/* roundedRect helper */
function roundedRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* --------------- UI events --------------- */
captureBtn.addEventListener('click', ()=>{ captureSequence(); });
saveBtn.addEventListener('click', ()=>{
  if(!composedDataUrl){ showError('ã¾ã åˆæˆç”»åƒãŒã‚ã‚Šã¾ã›ã‚“'); return; }
  downloadDataUrl(composedDataUrl, `realcam_${Date.now()}.jpg`);
});
openResultBtn.addEventListener('click', ()=>{
  if(!composedDataUrl) return;
  resultModal.style.display = 'flex';
  resultModal.setAttribute('aria-hidden','false');
});

/* retake / download / send */
retakeBtn.addEventListener('click', ()=>{
  resultModal.style.display = 'none';
  finalPreview.src = '';
  composedDataUrl = null;
  rearCanvasEl = frontCanvasEl = null;
  saveBtn.disabled = true; openResultBtn.disabled = true;
  statusEl.textContent = 'Tap to capture';
});
downloadBtn.addEventListener('click', ()=>{
  if(!composedDataUrl) return;
  downloadDataUrl(composedDataUrl, `realcam_${Date.now()}.jpg`);
});
sendBtn.addEventListener('click', ()=>{
  // SENDã‚¢ãƒ‹ãƒ¡ï¼ˆã‚«ãƒ¼ãƒ‰ä¸Šã«ã‚¢ãƒ‹ãƒ¡ï¼‰
  resultCard.classList.add('send-anim');
  setTimeout(()=>{
    resultModal.style.display = 'none';
    resultCard.classList.remove('send-anim');
    alert('é€ä¿¡ã—ãŸãƒ•ãƒªã‚’ã—ãŸã‚ˆã€œï¼ˆå®Ÿéš›ã®ã‚·ã‚§ã‚¢ã¯ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ï¼‰ğŸ’–');
    retakeBtn.click();
  },700);
});

/* helper: force download */
function downloadDataUrl(dataUrl, filename){
  const a=document.createElement('a');
  a.href=dataUrl; a.download=filename;
  document.body.appendChild(a); a.click(); a.remove();
}

/* page load check: camera support */
if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
  showError('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ã‚«ãƒ¡ãƒ©APIéå¯¾å¿œã§ã™ã€‚Safariæœ€æ–°ç‰ˆã§httpsç’°å¢ƒã‚’ä½¿ã£ã¦ã­ã€‚');
} else {
  statusEl.textContent = 'æº–å‚™OK â€” Captureã‚’æŠ¼ã—ã¦ã­âœ¨';
}

/* æœ€å¾Œã«ã€Safariã§ã‚ˆãã‚ã‚‹ã‚«ãƒ¡ãƒ©å‹•ã‹ãªã„ã‚±ãƒ¼ã‚¹ã®è»½ã‚¢ãƒ‰ãƒã‚¤ã‚¹ */
console.log('Tip: Safariã§ã‚«ãƒ¡ãƒ©åŠ¹ã‹ãªã„å ´åˆã¯ https / ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒãƒ¼ / è¨­å®šâ†’Safariâ†’ã‚«ãƒ¡ãƒ© ã‚’ç¢ºèªã—ã¦ã­');
</script>
</body>
</html>